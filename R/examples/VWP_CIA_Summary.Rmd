---
date: "`r format(Sys.time(), '%m/%d/%Y')`"
author: ""
title: "VWP CIA Summary - [INSERT PROJECT NAME HERE]"
output: 
  officedown::rdocx_document:
    mapstyles:
      Normal: ['First Paragraph']
    page_margins:
      bottom: 0.5
      top: 0.5
      right: 1
      left: 0.5
      header: 0.0
      footer: 0.0
params: 
  rseg.hydroid: 462757 # Ex: Crooked Run = 476998, SF Powell below BSG = 477140, SF Powell at dam: 462757
  fac.hydroid: 72672 # Ex: Blue Ridge Shadows = 71977, BIG STONE GAP WTP = 72672: "runid_6014"
  runid.list: [ "runid_400","runid_600" ]
  fac.metric.list: [ "base_demand_mgy", "wd_mgy", "unmet_demand_mgy","base_demand_mgd", "wd_mgd","ps_mgd","unmet30_mgd" ]
  rseg.metric.list: [ "Qout","remaining_days_p0","l30_Qout",
    "l90_Qout","consumptive_use_frac","wd_cumulative_mgd","ps_cumulative_mgd" ]
  intake_stats_fid: FALSE
  intake_stats_runid: 11
  intake_stats_varname: "Qintake"
  preferred_runid: "runid_600"
  impoundment_fid: FALSE
  additional_rseg_ids: FALSE
---

```{r setup, include=FALSE}
#"runid_201","runid_401","runid_6014","runid_6011","runid_6013","runid_6015","runid_6012"
#https://cran.r-project.org/web/packages/officedown/officedown.pdf
#https://ardata-fr.github.io/officeverse/officedown-for-word.html#insert-sections
knitr::opts_chunk$set(echo = TRUE, fig.cap = TRUE)
library(officedown)
library(officer)
library(flextable)
library(hydrotools)
library(rjson)
basepath='/var/www/R'
source('/var/www/R/config.R')
ds <- RomDataSource$new("http://deq1.bse.vt.edu/d.dh", rest_uname)
ds$get_token(rest_pw)

#source(paste(github_location,"/hydro-tools/R/om_cia_table.R",sep="")) #Used during development
source("https://raw.githubusercontent.com/HARPgroup/hydro-tools/master/VAHydro-2.0/fn_get_prop.R") #Used during development
source("https://raw.githubusercontent.com/HARPgroup/hydro-tools/master/VAHydro-2.0/rest_functions.R") #Used during development
source("https://raw.githubusercontent.com/HARPgroup/hydro-tools/master/VAHydro-2.0/find_name.R") #Used during development
source("https://raw.githubusercontent.com/HARPgroup/hydro-tools/master/R/fac_utils.R") #Used until fac_utils is packaged
# Could also use:
#source("https://raw.githubusercontent.com/HARPgroup/hydro-tools/master/VAHydro-2.0/run_text.R") #Used during development

fp <- fp_par(
  text.align = "center", 
  padding.bottom = 20, padding.top = 120, 
  border.bottom = fp_border())

ft <- fp_text(shading.color='#EFEFEF', bold = TRUE)

```


```{r UserInputs, include=FALSE}
site.plots <- omsite #image files use http

#SPECIFY MODELS AND RUNIDS OF INTEREST

rseg.hydroid <- params$rseg.hydroid
fac.hydroid <- params$fac.hydroid
runid.list <- params$runid.list
fac.metric.list <- params$fac.metric.list
rseg.metric.list <- params$rseg.metric.list
intake_stats_fid <- params$intake_stats_fid
intake_stats_runid <- params$intake_stats_runid
intake_stats_varname <- params$intake_stats_varname
preferred_runid <- params$preferred_runid
impoundment_fid <- params$impoundment_fid
additional_rseg_ids <- params$additional_rseg_ids

if (is.logical(intake_stats_fid)) {
  intake_stats_fid = fac.hydroid
}
#runid.list <- c('runid_400','runid_600')
#runid.list <- c('runid_201','runid_401')
rlist <- gsub('runid_', '', runid.list)

# SALEM WTP:
# rseg.hydroid <- 68327
# fac.hydroid <- 73112
# runid.list <- c('runid_11','runid_12','runid_13')
# 
# fac.metric.list <- c('wd_mgd','ps_mgd','unmet30_mgd')
# rseg.metric.list <- c("Qout","Qbaseline","l30_Qout","l90_Qout","consumptive_use_frac","wd_cumulative_mgd","ps_cumulative_mgd")

#RSEG MODEL INFO
print(paste("searching", site,"for river segment id", rseg.hydroid))

#base_url = site, entity_id = rseg.hydroid

rseg.model <- om_get_model(site, rseg.hydroid)
rseg.elid <- om_get_prop(site, rseg.model$pid, entity_type = 'dh_properties','om_element_connection')$propvalue

#FAC MODEL INFO
fac.model <- om_get_model(site, fac.hydroid, model_varkey = 'om_water_system_element')
fac.elid <- om_get_prop(site, fac.model$pid, entity_type = 'dh_properties','om_element_connection')$propvalue

if (intake_stats_fid == fac.hydroid) {
  istats_elid = fac.elid
} else if (intake_stats_fid == rseg.hydroid) {
  istats_elid = rseg.elid
} else {
  istats_model <- RomProperty$new(
    ds,
    list(entity_type='dh_feature', featureid = intake_stats_fid, propcode="vahydro-1.0"),
    TRUE
  )
  istats_elid <- as.integer(as.character(istats_model$propvalues('om_element_connection')$propvalue))
}


if (exists("json_obj_url")) {
  fac_obj_url <- paste(json_obj_url, fac.model$pid, sep="/")
  fac_model_info <- om_auth_read(fac_obj_url, token,  "text/json", "")
  fac_model_info <- fromJSON(fac_model_info)
  rseg_obj_url <- paste(json_obj_url, rseg.model$pid, sep="/")
  rseg_model_info <- om_auth_read(rseg_obj_url, token,  "text/json", "")
  rseg_model_info <- fromJSON(rseg_model_info)
  # get report cusomtizations
  fac_report_info = find_name(fac_model_info, "reports")
  rseg_report_info = find_name(rseg_model_info, "reports")
  if (!is.logical(impoundment_fid)) {
    imp_model <- RomProperty$new(
      ds,
      list(entity_type='dh_feature', featureid = impoundment_fid, propcode="vahydro-1.0"),
      TRUE
    )
    imp_obj_url <- paste(json_obj_url, imp_model$pid, sep="/")
    imp_model_info <- om_auth_read(imp_obj_url, token,  "text/json", "")
    imp_model_info <- fromJSON(imp_model_info)
  }
} else {
  message("Error: json_obj_url is undefined.  Can not retrieve model and scenario information. (Hint: Use config.R to set json_obj_url) ")
  fac_model_info <- list()
  rseg_model_info <- list()
}

fac_default_info = list(
  model_overview = list(
    "value" = "Facility intake model overview not provided."
  ),
  intake_name = list(
    "value"  = "un-named intake"
  )
)
rseg_default_info = list(
  model_overview = list(
    "value" = "River segment model overview not provided."
  )
)

fac_report_info <- merge.list(fac_report_info, fac_default_info)
rseg_report_info <- merge.list(rseg_report_info, rseg_default_info)   

# Pre load the output runs so we have them available for later use
# I think the om_get_prop here is no longer needed, rather, we 
short_names = list()
run_names = list()

for (i in 1:length(runid.list)){
  # get fac model run prop
  # get river model run prop 
  runid.i <- runid.list[i]
  run.i <- sub("runid_", "", runid.i)
  
  # TODO: prepopulate runid_XXX$report$facility_default_reports and riverseg_default_reports on the om_model_scenario variable to load as a default for these.  For example, runid11 is *always* the current WSP run, so there should be no need to give it a short name, or scenario name at the individual facility level.
  # stash short names since they are used frequently
  fac_run_info <- find_name(fac_model_info,runid.i)
  f_rep <- find_name(fac_run_info,'reports')
  # get the short name
  if (is.null(f_rep$scenario_short_name$value)) {
    short_names[[runid.i]] <- runid.i
  } else {
    short_names[[runid.i]] = as.character(f_rep$scenario_short_name$value)
  }
  # get the long name
  if (is.null(f_rep$scenario_name$value)) {
    run_names[[runid.i]] <- runid.i
  } else {
    run_names[[runid.i]] = as.character(f_rep$scenario_name$value)
  }
}


```


# VAHydro Model:


## VAHydro
The comprehensive VAHydro hydrologic model is used by the DEQ Office of Water Supply to evaluate instream and off-stream beneficial uses for non-tidal surface water withdrawals throughout Virginia. This model also simulates streamflow with inputs such as precipitation, climate, land use, and topography, as well as local data collected through DEQ water supply planning and reporting programs, which includes all known withdrawals and discharges, as well as operational rules of Virginia Water Protection (VWP) permits and major hydrologic features such as reservoirs.

The VAHydro model is built on the rainfall-evaporation-runoff (RER) time-series from the Chesapeake Bay Model Phase 6^[ [Chesapeake Bay Program Phase 6 Model](https://www.chesapeakebay.net/documents/Phase_6_Modeling_Tools_1-page_factsheet_12-18-17.pdf).]. The VAHydro model simulates conditions from 1984-2014 in the Chesapeake Bay watershed drainage, and 1984-2005 in the rivers flowing outside of the Chesapeake Bay watershed. The VAHydro model features high-resolution hydrologic subsections called “river segments” (over 600 river segments in total), roughly the size of HUC 10 hydrologic units, with additional high-resolution segments added for VWP modeling projects as needed.


## Cumulative Impact Analysis (CIA)
DEQ assesses water supply sustainability through Cumulative Impact Analysis (CIA). CIA is a modeling and analysis approach that takes into account the varied hydrologic processes occurring throughout a river network (including meteorological and human water use). By simulating a daily water balance for every individual river segment within a watershed, DEQ is able to evaluate the potential “cumulative impact” of all streamflow changes occurring upstream and downstream of any location within the river system, as well as the downstream impact of a specific proposed or permitted surface water withdrawal.

The goal of the following analysis is to estimate the potential impacts of the proposed water withdrawal upon existing beneficial uses, including both in-stream and off-stream uses. In addition, cumulative impacts from all existing withdrawals are included in the evaluation.


\newpage
# Project Introduction

This project consists of an existing water intake constructed in the 1960's with an upgrade in the early 1980's. The Town owns and operates the Big Cherry Dam located approximately 3 miles upstream from the intake structure. The Town's water treatment plant operators control the amount of water discharging the dam into the Powell River and all of the stream by-pass flow to meet the previous permit requirements of 4.0 MOD of maximum withdrawal and 0.50 MGD of by-pass flow. This is always true unless the dam is overflowing exceeding the amount of water required from various rainfall events. Therefore, the existing/proposed maximum withdrawal amounts will not have an impact on the stream in terms of rates, volumes, frequency, etc. This is a daily activity as it serves the existing water treatment plant.

Permit: Big Cherry Dam, 01-0688  
Permit Dates: 2003-08-23 to 2018-08-22  

* **Annual Withdrawal Limit** = 1168 MG/yr (3.2 MGD)
    + (historically they withdraw ~2 MGD on average)
* **Daily Withdrawal Limit** = 4 MGD 
* **Flow-by** = 0.5 MGD 
<br>
<br>
<br>

## Location Map

```{r GrabLocationMap, include=FALSE, echo=FALSE}
fig_prop <- om_get_prop(site,fac.model$pid, "dh_properties", "fig.location_map")
```

```{r LocationMap, echo=FALSE, results = "asis"}

if (!is.logical(fig_prop)) {
  map_path <- fig_prop$propcode
  cat(paste0("![](",map_path,")"),"\n")
} else {
  cat(paste0("*No location map available for this facility model*"))
}
``` 

\newpage
# Model Overview and Scenario Descriptions

```{r ModelOverview, echo=FALSE, results = "asis"}

cat("__River Model Description__\n")
cat(paste(rseg_report_info$model_overview$value,"\n\n"))
cat("__Facility & Intake Model Description__\n")
cat(paste(fac_report_info$model_overview$value,"\n\n"))
```

The following model scenarios were simulated in order to determine the most effective means of meeting the project need and all other in-stream beneficial uses:

```{r LoadRunInfo, echo=FALSE, results = "asis"}
for (i in 1:length(runid.list)){
  # get fac model run prop
  # get river model run prop 
  runid.i <- runid.list[i]
  run.i <- sub("runid_", "", runid.i)
  run_info <- find_name(fac_model_info,runid.i)
  
  if (is.null(run_info$reports)) {
    cat(paste("*", paste0("__",run_info$name,"__"),"-","Run report information not provided.","\n"))
  } else {
    ri <- run_info$reports
    cat(
      paste(
        "*", 
        paste0(
          "__",ri$scenario_name$value,"__", 
        " (", ri$scenario_short_name$value, ")"
        ),
        "-",run_info$reports$scenario_intro$value,"\n\n")
      )
  }
  
}

```

\newpage  
__Historical Intake Flows and Drought Flow Indicators__  

The VAHydro model is used to estimate flows at the project intake, including the impact of all cumulative withdrawals, discharges and management rules upstream of the withdrawal location. The models estimates of currently available flows are presented in Table 1.  The Virginia Drought Assessment and Response Plan^[ [Virginia Drought Assessment and Response Plan](https://www.deq.virginia.gov/home/showpublisheddocument/5115/637490843054630000), developed by the Drought Response Technical Advisory Committee in response to Executive Order #39, March 28, 2003.] employs non-exceedance flow percentiles as indicators of drought conditions at particular stream-gaging stations used to monitor drought conditions.  Representative daily streamflows above the 25th percentile for return flow frequency represent normal conditions with respect to drought.  Representative daily streamflows between the 10th and 25th percentiles represent drought watch conditions. Representative daily streamflows between the 5th and 10th percentiles represent drought warning conditions.  Representative daily streamflows below the 5th percentile indicate drought emergency conditions.

```{r LoadSiteInfo, include=FALSE}
dat_current <- om_get_rundata(istats_elid, intake_stats_runid, omsite, FALSE)
# catch instances where older models did not have Qintake
# does this have an impoundment sub-comp and is imp_off = 0?
cols <- names(dat_current)
if(!(intake_stats_varname %in% cols)) {
  dat_current[,intake_stats_varname] <- dat_current$Qriver
}
intake_sum_current <- om_flow_table(dat_current, intake_stats_varname)
ex_col = "10%"
jan_ex <- intake_sum_current[1,ex_col]
if (jan_ex == 0) {
  ex_col = "25%"
}
jan_ex <- intake_sum_current[1,ex_col]
non_ex_text <- paste0("For example, in the table below the ",ex_col," column states that ",ex_col," of flows within the month of January would be less than ", round(jan_ex,0), " cfs.")
drun_info <- find_name(fac_model_info,paste0("runid_",intake_stats_runid))
demand_url <- drun_info$fig.monthly_demand$code
```

```{r SiteTable, echo=FALSE, results = "asis"}
#Round Table Values (Following McGurk request: "The tabulated values should be rounded to the nearest whole number.  The flow estimates at the stream gages are not precise or accurate enough for digits to the right of the decimal, and are not reported that way.  Therefore, modeled values should not be considered more accurate.")
round_intake_sum_current <- intake_sum_current[2:length(intake_sum_current)]
round_intake_sum_current <- round(round_intake_sum_current,0)
intake_sum_current <- cbind(intake_sum_current[1],round_intake_sum_current)

# Format table
ft <- qflextable(intake_sum_current)
ft <- theme_box(ft)
ft <- bg(ft, bg = "#EFEFEF", part = "header")
cat(paste("__Table 1:__ Modeled monthly current flow statistics for", fac_report_info$intake_name$value, "in cubic feet per second (cfs). Columns show the minimum (Min) and average (Mean) modeled flow, and a range of non-exceedance flow percentiles, that is, the column header indicates the percent of flows that do *not* exceed the given value. For example, the", paste0("\"",ex_col, "\""), "states that only", ex_col, "of flows in the given month are expected to be less than the indicated value, and therefore, 90% of the flows in that month are expected to be greater than the given value.", non_ex_text) )
ft
if (!is.null(demand_url)) {
    cat("\n\n## Facility Base Demand Before Conservation: ", short_names[[runid.i]],"\n\n")
    cat(paste0("![](",demand_url,")"),"\n")
    cat("\n\n\\pagebreak\n")
} else {
  #cat("NULL demand_url\n")
  cat(" ")
}
```
  
\newpage
# Results
## Summary

Four scenarios are presented below to examine the alternatives for this permit re-issuance.  A summary of how permit rules affect available water for this permit, and how this operation may impact instream beneficial uses, and other downstream water withdrawals is presented.   

```{r LoadRunResults, echo=FALSE, results = "asis"}
for (i in 1:length(runid.list)){
  # get fac model run prop
  # get river model run prop 
  runid.i <- runid.list[i]
  run.i <- sub("runid_", "", runid.i)
  run_info <- find_name(fac_model_info,runid.i)
  if (is.null(run_info$reports)) {
    cat(paste("*", paste0("__",run_names[runid.i],"__"),"-","Run analysis not provided.","\n"))
  } else {
    ri <- run_info$reports
    cat(
      paste(
        "*", 
        paste0(
          "__",ri$scenario_name$value,"__"
        ),
        "-",run_info$reports$scenario_analysis$value,"\n")
      )
  }
  
}
```

## Conclusion

```{r LoadConclusions, echo=FALSE, results = "asis"}

runid.i <- preferred_runid
run.i <- sub("runid_", "", runid.i)
run_info <- find_name(fac_model_info,runid.i)
if (is.null(run_info$reports)) {
  cat(paste("*", paste0("__",run_names[runid.i],"__"),"-","Preferred scenario, ", runid.i, ", conclusions not provided.","\n", "Conclusions should be stored in [model] -> ", run.i, " -> reports -> conclusions"))
} else {
  cat(
    paste(
      "*", 
      paste0(
        "__",run_info$reports$scenario_name$value,"__"
      ),
      "-",run_info$reports$conclusions$value,"\n")
    )
}

```


```{r LoadStatsTable, include=FALSE}
# todo: pass in fac_model_info and rseg_model_info to:
#       - eliminate redundant data retrieval, since all data that is pulled inside om_cia_table via om_vahydro_metric_grid is already inside fac_model_info and rseg_model_info data structures
#       - eliminate having data retrieval and data formatting/analysis in the same function (best practice)
# this could now, I think, be simplified as:
# om_cia_table(fac_model_info, rseg_model_info)
statsdf <- om_cia_table(
  fac_model_info = fac_model_info,
  rseg_model_info = rseg_model_info,
  runid.list = runid.list, 
  fac.metric.list = fac.metric.list,
  rseg.metric.list = rseg.metric.list,
  site,
  omsite
)

statsdf <- cbind(rownames(statsdf),statsdf)
names(statsdf)[names(statsdf) == 'rownames(statsdf)'] <- 'Desc'
statsdf_raw <- statsdf

statsdf_sql <- paste('SELECT
                  CASE
                    WHEN "Desc" = "Qout" THEN "Flow Out (cfs) - (i.e mean flow)"
                    WHEN "Desc" = "Qbaseline" THEN "Flow Baseline (cfs)"
                    WHEN "Desc" = "remaining_days_p0" THEN "Minimum Days of Storage Remaining"
                    WHEN "Desc" = "l30_Qout" THEN "30 Day Low Flow (cfs) (i.e drought flow)"
                    WHEN "Desc" = "l90_Qout" THEN "90 Day Low Flow (cfs) (i.e drought flow)"
                    WHEN "Desc" = "consumptive_use_frac" THEN "Consumptive Use Fraction"
                    WHEN "Desc" = "wd_cumulative_mgd" THEN "Cumulative Withdrawal (MGD)"
                    WHEN "Desc" = "ps_cumulative_mgd" THEN "Cumulative Point Source (MGD)" 
                    WHEN "Desc" = "wd_mgd" THEN "Withdrawal Met (MGD)"  
                    WHEN "Desc" = "ps_mgd" THEN "Point Source (MGD)"  
                    WHEN "Desc" = "unmet30_mgd" THEN "Maximum 30 day potential unmet demand (MGD)"
                    WHEN "Desc" = "richness_change_abs" THEN "Richness Change (abs)"
                    WHEN "Desc" = "richness_change_pct" THEN "Richness Change (%)"
                    WHEN "Desc" = "rseg_model" THEN "River Segment Model Statistics:"
                    WHEN "Desc" = "fac_model" THEN "Facility Model Statistics:"
                    WHEN "Desc" = "base_demand_mgy" THEN "Base Demand (MGY)"
                    WHEN "Desc" = "wd_mgy" THEN "Withdrawal (MGY)"
                    WHEN "Desc" = "unmet_demand_mgy" THEN "Unmet Demand (MGY)"
                    WHEN "Desc" = "base_demand_mgd" THEN "Requested Demand (MGD)" 
                    ELSE Desc
                  END AS Description, *
                 FROM statsdf
                 WHERE Desc NOT IN ("Rseg_Stats","Facility_Stats","riverseg","run_date","starttime","endtime","richness_change_abs","richness_change_pct")
                 ',sep='')
statsdf <- sqldf(statsdf_sql)
statsdf <- statsdf[,-2]
```


\newpage
## Detailed Cumulative Impact Analysis
The following "Summary of Results" table summarizes the cumulative impacts to flows, aquatic life, and off-stream demand for the project. The section entitled “River Segment Model Statistics” contains mean flows (Flow Out), and drought flows (30 and 90 Day Low Flow), as well as an estimated Consumptive Use Fraction (See description below) as a result of all withdrawals (Cumulative Withdrawal) and discharges (Cumulative Point Source) in the watershed. Minimum Days of Storage Remaining describes the number of days of remaining storage available during the driest period of the model simulation (applicable to impoundment models only). Total Number of Days with Storage < 50% describes the number of days in the simulation in which reservoir levels fall below 50% of full storage. The section entitled “Facility Model Statistics” shows the withdrawals, return flows (Point Source), and the model estimate for potential unmet demand due to demands exceeding the allowable withdrawal at the intake based on the cumulative conditions in the watershed and the flow-by rules in effect. There will be one or more columns in this table representing each scenario considered for this analysis.

### Glossary of Cumulative Impact Modeling Terms
- Consumptive Use Fraction (CU): This is calculated as a fraction of modeled Flow, so it is CU = 1.0 - (Flow / Flow_Baseline), where Flow_Baseline = (Flow + WD - PS), and WD and PS are the total cumulative withdrawals and point source discharges above the point in the stream.  In other words, for calculating baseline flow, we take modeled outflow from the river, add the withdrawals back in, and subtract the point source in order to estimate a baseline flow balance.  This almost always ends up being a higher number than the modeled Flow out, so it tells us the fraction of baseline flow that is consumed.  Occasionally there are water transfers and point sources from groundwater, or point sources that cross watershed boundaries that can make the CU fraction in some watersheds negative, i.e. Flow > Flow_Baseline.
- 30 Day Low Flow: *DESCRIPTION NEEDED
- 90 Day Low Flow: *DESCRIPTION NEEDED
- *Additional DESCRIPTIONS NEEDED for other table metrics that aren't clearly understood

<!---BLOCK_LANDSCAPE_START--->
### Summary of Results:
```{r StatsTable, echo=FALSE}
ft <- qflextable(statsdf)

# Set column widths
ft <- width(ft, j = 2:length(statsdf[1,]), width = 1.9)
ft <- width(ft, j = 1, width = 2.5)

# Add header row -----------------------------------------------------------------------------------
# ft <- add_header_row(x = ft, values = c("", "Scenario Alternatives"),colwidths = c(3, 4))

# Set theme
ft <- theme_box(ft)

# Set background color of select rows --------------------------------------------------------------
ft <- bg(ft, bg = "#EFEFEF", part = "header")
ft <- bg(ft, i = ~ Description == "River Segment Model Statistics:", bg = "#EFEFEF", part = "body")
ft <- bg(ft, i = ~ Description == "Facility Model Statistics:", bg = "#EFEFEF", part = "body")
fontsize(ft, size = 9)
```
<!---BLOCK_LANDSCAPE_STOP--->


### Analysis of Reservoir Storage:
The following reservoir storage plots depict changes in reservoir storage under each scenario (indicated in black), as well as simulated inflow to the reservoir (blue), simulated outflow from the reservoir (green), and system demand for the given scenario (red). For water supply reservoirs, a minimum of 60 days of remaining storage over the course of the simulation is recommended. System demand varies seasonally.

```{r ResPLOTS, echo=FALSE, message=FALSE, results = "asis"}

# check river model for plots
for (i in 1:length(runid.list)){
  # get fac model run prop
  # get river model run prop 
  runid.i <- runid.list[i]
  run_info <- find_name(rseg_model_info,runid.i)
  fig_prop <- find_name(run_info, "fig.imp_storage.all")
  if (!(is.null(fig_prop))) {
    fig_path <- fig_prop$code
    # we have an image, show it 
    cat("\n\n#### Reservoir Storage: ", short_names[[runid.i]],"\n\n")
    cat(paste0("![](",fig_path,")"),"\n")
    cat("\n\n\\pagebreak\n")
  } else {
    # tbd: try impoundment linked to river segment.
    print(paste("No active impoundment found for run id",runid.i))
  }
  if (!is.logical(impoundment_fid)) {
    run_info <- find_name(imp_model_info,runid.i)
    fig_prop <- find_name(run_info, "fig.imp_storage.all")
    if (!(is.null(fig_prop))) {
      fig_path <- fig_prop$code
      # we have an image, show it 
      cat("\n\n#### Reservoir Storage: ", short_names[[runid.i]],"\n\n")
      cat(paste0("![](",fig_path,")"),"\n")
      cat("\n\n\\pagebreak\n")
    } else {
      # tbd: try impoundment linked to river segment.
      print(paste("No active impoundment found for run id",runid.i,"on impoundment feature", impoundment_fid)) 
    }
  }
}

``` 

\newpage

### Analysis of Potential Unmet Demand at the River Intake:
Heatmaps are data plotting tools that help visualize data as magnitudes of color intensity. The following heatmaps depict the number of days with unmet demands for each month of the simulation (due to demands exceeding allowable withdrawal at the intake based on the cumulative conditions in the watershed and the flow-by rules in effect). The heatmap cells show the amount of unmet demand for each month [Number of Unmet Days & Amount (MGD)]. Hydrographs are shown for the period of the simulation with greatest unmet demand.

```{r UnmetDemandPLOTS, echo=FALSE, message=FALSE, results = "asis"}

# check facility model for plots
for (i in 1:length(runid.list)){
  # get fac model run prop
  # get river model run prop 
  runid.i <- runid.list[i]
  run.i <- sub("runid_", "", runid.i)
  fac_run <- find_name(fac_model_info, runid.i)
  fig_prop <- invisible(find_name(fac_run, "fig.unmet_heatmap_amt"))
  if (!(is.null(fig_prop))) {
    fig_path <- fig_prop$code
    # we have an image, show it 
    cat("\n\n#### Heatmap: ",short_names[[runid.i]],"\n\n")
    cat(paste0("![](",fig_path,")"),"\n")
  }
  fig_prop <- invisible(find_name(fac_run, "fig.30daymax_unmet"))
  if (!(is.null(fig_prop))) {
    fig_path <- fig_prop$code
    # we have an image, show it 
    cat("\n\n#### Hydrograph: ",short_names[[runid.i]],"\n\n")
    cat(paste0("![](",fig_path,")"),"\n")
    #cat("\n\n\\pagebreak\n")
  }
  fig_prop <- invisible(find_name(fac_run, "fig.imp_storage.all"))
  if (!(is.null(fig_prop))) {
    fig_path <- fig_prop$code
    # we have an image, show it 
    cat("\n\n#### Reservoir Storage: ",short_names[[runid.i]],"\n\n")
    cat(paste0("![](",fig_path,")"),"\n")
  } else {
    # JK - do we want to simply supress in order to have better formatting? or maybe keep a count
    # of missing images so we can alert the user to which entities lack impoundments?
    print(paste("No local facility impoundment for ",short_names[[runid.i]]))
  }
  cat("\n\n\\pagebreak\n")
  
}

``` 

\newpage

### Additional Model Flow Plots:

```{r FDCplots,fig.width=6.25,fig.height=4.8,echo=FALSE,results='hide', warning = FALSE, message=FALSE}

#runid.list
########################################################## 
batch_list <- list()
for (i in 1:length(runid.list)) {
  runid_i <- runid.list[i]
  runid_i <- sub("runid_", "", runid_i)  
  batch_list_i <- list(list(runid = runid_i,legend_text = paste("Flow (Qout: ",runid_i,")",sep="")))
  batch_list <- append(batch_list, batch_list_i)
}
########################################################## 

#i <- 3
for (i in 1:length(batch_list)) {
  runid_i <- batch_list[[i]]$runid
  legend_text_i <- batch_list[[i]]$legend_text

  ########################################################################################
  # RETRIEVE RSEG AND FAC DATA, JOIN INTO ONE TABLE
  rseg_dat <- om_get_rundata(rseg.elid, runid_i, site = omsite) 
  rseg_df <- data.frame(rseg_dat)
  rseg_df <- cbind("date" = rownames(rseg_df),rseg_df)
  
  fac_dat <- om_get_rundata(fac.elid, runid_i, site = omsite)
  fac_df <- data.frame(fac_dat)
  fac_df <- cbind("date" = rownames(fac_df),fac_df)
  
  dat_join <- sqldf(paste("SELECT *
                          FROM rseg_df AS a
                          LEFT OUTER JOIN fac_df AS b
                          ON a.date = b.date")
                    )
  ########################################################################################
  # FLOW DURATION CURVE PLOTS
  fdc_plot <- hydroTSM::fdc(
                          #cbind(dat_join$Qnatural, dat_join$Qout),
                          cbind(dat_join$available_mgd, dat_join$Qout),
                          yat = c(0.10,1,5,10,25,100,400),
                          #leg.txt = c("Flow (Natural)",legend_text_i),
                          leg.txt = c(paste("Flow (available_mgd: ",runid_i,")",sep=""),legend_text_i),
                          ylab = "Q, [cfs]",
                          ylim=c(1.0, 5000)
                        )
  print(fdc_plot)
  ########################################################################################
  # DROUGHT PERIOD PLOT 
  xmn <- as.Date('1999-01-01')
  xmx <- as.Date('1999-12-31')
  ymn <- 0
  ymx <- 1000
  par(mar = c(5,5,2,5))
  hydrograph_dry <- plot(as.numeric(dat_join$available_mgd)~as.Date(dat_join$date),
                            type = "l", lty=2, lwd = 1,ylim=c(ymn,ymx),xlim=c(xmn,xmx),
                            ylab="Flow (cfs)",xlab=paste("\nDate\n",xmn,"to",xmx),
                            main = "Hydrograph: Dry Period")
  par(new = TRUE)
  plot(as.numeric(dat_join$Qout)~as.Date(dat_join$date),type = "l",col='brown3', lwd = 2, 
        axes=FALSE,ylim=c(ymn,ymx),xlim=c(xmn,xmx),ylab="",xlab="")
  legend("topright",legend=c(paste("Flow (available_mgd: ",runid_i,")",sep=""),legend_text_i),
         col=c("black","brown3"), 
         lty=c(2,1), lwd=c(1,2), cex=1)
  print(hydrograph_dry)
  ########################################################################################
  # WET PERIOD PLOT
  xmn <- as.Date('2003-01-01')
  xmx <- as.Date('2003-12-31')
  ymn <- 0
  ymx <- 5000
  par(mar = c(5,5,2,5))
  hydrograph_wet <- plot(as.numeric(dat_join$available_mgd)~as.Date(dat_join$date),
                            type = "l", lty=2, lwd = 1,ylim=c(ymn,ymx),xlim=c(xmn,xmx),
                            ylab="Flow (cfs)",xlab=paste("\nDate\n",xmn,"to",xmx),
                            main = "Hydrograph: Wet Period")
  par(new = TRUE)
  plot(as.numeric(dat_join$Qout)~as.Date(dat_join$date),type = "l",col='brown3', lwd = 2, 
        axes=FALSE,ylim=c(ymn,ymx),xlim=c(xmn,xmx),ylab="",xlab="")
  legend("topright",legend=c(paste("Flow (available_mgd: ",runid_i,")",sep=""),legend_text_i),
         col=c("black","brown3"), 
         lty=c(2,1), lwd=c(1,2), cex=1)
  print(hydrograph_wet)
  
} #CLOSE FOR LOOP

```


\newpage

# Appendix A - Ecological Impacts Assessment:

## Elfgen:
In response to a need for better environmental flow metrics, DEQ has developed a new framework for characterizing relations between streamflow and aquatic organism species richness. Part of an evolving approach to managing environmental flows for maintaining aquatic life; this methodology builds on existing minimum instream ow approaches, allowable withdrawals as a percentage of flow, and extensive flow-habitat studies. For the first time this new framework may allow quantification of potential species loss resulting from flow change, and may offer an improved understanding of aquatic life risk variability due to geographic location, stream size and local scale.

This new flow-ecology framework referred to as “elfgen” (*pronounced elf-jen*) derives its name from Ecological Limit Function (ELF) generation (*ELF-gen*). In order to calculate river segment-level richness change, elfgen is first used to produce ELFs, or relations between stream flow and species richness at the HUC 8 scale (See plot below). This is achieved using long term datasets for both ecological and hydrologic data. Ecological data (Fish species richness) is sourced from the VAHydro-EDAS dataset. Hydrologic data (Average Annual Flow) is sourced from the National Hydrography Dataset Plus. The Richness Change values presented in the table below are derived from this flow-ecology relation.


```{r GrabELFPlot, include=FALSE, echo=FALSE}
# Need to have a switch based on draiange area with text such as:
# Ecological Limit Functions are not available for this location because the drainage area exceeds 800 square miles, which is beyond the applicable range of current mean flow based ecological limit functions.


run_container <- om_get_prop(site, rseg.model$pid, entity_type = 'dh_properties',runid.list[1])
fig_path = FALSE
elfgen_EDAS_huc8 <- om_get_prop(site, run_container$pid, entity_type = 'dh_properties','elfgen_EDAS_huc8')
if (!is.logical(elfgen_EDAS_huc8)) {
  fig.elfgen <- om_get_prop(site, elfgen_EDAS_huc8$pid, entity_type = 'dh_properties','fig.elfgen')
  fig_path <- fig.elfgen$propcode
}
``` 

```{r elfPlot, echo=FALSE, results = "asis"}
if (!is.logical(fig_path)) {
  cat(paste0("![](",fig_path,")"),"\n")

} else {
  cat(paste0("*No elfgen plot available for this model*"))
}
```

\newpage

## Richness Change Metric Table:
Estimates for richness change are presented both as an absolute number of species (Richness Change (abs)) and as a percentage of the total number of species present (Richness Change (%)). Richness change calculations are derived from the estimated percent total consumptive use^[Kleiner et al: [https://onlinelibrary.wiley.com/doi/full/10.1111/1752-1688.12876](https://onlinelibrary.wiley.com/doi/full/10.1111/1752-1688.12876) & Rapp et al: [https://onlinelibrary.wiley.com/doi/full/10.1111/1752-1688.12877](https://onlinelibrary.wiley.com/doi/full/10.1111/1752-1688.12877)]. Note: elfgen methodology only applicable for watersheds < 800 cfs mean annual flow.

```{r LoadRichnessTable, include=FALSE}
elfgen_df <- statsdf_raw
elfgen_sql <- paste('SELECT
                      CASE
                        WHEN "Desc" = "rseg_model" THEN "River Segment Model Statistics:"
                        WHEN "Desc" = "consumptive_use_frac" THEN "Consumptive Use Fraction"
                        WHEN "Desc" = "wd_cumulative_mgd" THEN "Cumulative Withdrawal (MGD)"
                        WHEN "Desc" = "richness_change_abs" THEN "Richness Change (abs)"
                        WHEN "Desc" = "richness_change_pct" THEN "Richness Change (%)"
                        ELSE Desc
                      END AS Description, *
                    FROM elfgen_df
                    WHERE Desc IN ("rseg_model","consumptive_use_frac","wd_cumulative_mgd","richness_change_abs","richness_change_pct")
                    ',sep='')
elfgen_df <- sqldf(elfgen_sql)
elfgen_df <- elfgen_df[,-2]
```

```{r RichnessTable, echo=FALSE}
ft <- qflextable(elfgen_df)
# Set column widths
  ft <- width(ft, j = 2:length(elfgen_df[1,]), width = 1.9)
  ft <- width(ft, j = 1, width = 2)
# Set theme
  ft <- theme_box(ft)
# Set background color of select rows --------------------------------------------------------------
  ft <- bg(ft, bg = "#EFEFEF", part = "header")
  fontsize(ft, size = 9)
```


## Habitat (If Applicable):

\newpage


```{r LoadRsegWithdrawalsTable, include=FALSE}
if (isFALSE(additional_rseg_ids) == FALSE  & length(additional_rseg_ids) > 0) {
  users_df <- read.csv(paste(site,"/contains-mps-model-summary-export/",
                           rseg.hydroid,",",gsub(" ","",toString(additional_rseg_ids)),sep=""))
} else {
  users_df <- read.csv(paste(site,"contains-mps-model-summary-export",rseg.hydroid,sep="/"))
}
#########################################################################################  
#MP 5-yr Avg Current Annual Use (MGY)
#Facility 5-yr Avg Current Annual Use (MGY)
#Facility Projected 2040 Use (MGY)
users_sql <- paste('SELECT polygon_name AS "Sub-Watershed",
                          mp_bundle AS "MP Type",
                          mp_fstatus AS "MP Status",
                          mp_name AS "MP Name",
                          mp_wd_current_mgy AS "MP 5-yr Avg Use (MGY)",                
                          facility_name AS "Facility Name",
                          facility_wd_current_mgy AS "Facility 5-yr Avg Use (MGY)",
                          facility_wsp2020_2040_mgy AS "Facility 2040 Use (MGY)"
                   FROM users_df
                   ORDER BY mp_wd_current_mgy DESC
                  ')
#WHERE mp_wd_current_mgy > 0
usersdf <- sqldf(users_sql)
usersdf <- cbind(" "=seq.int(nrow(usersdf)),usersdf) #ADD COLUMN OF ROW NUMBER 
```

<!---BLOCK_LANDSCAPE_START--->
# Appendix B - Nearby Users Table:
```{r RsegWithdrawalsTable, echo=FALSE}
#cat(paste("MP 5-yr Avg Use (MGY) refers to the 5-year average current annual Use (MGY) based on reported withdrawals"))
users <- qflextable(usersdf)

# Set column widths
users <- width(users, j = 1, width = 0.3)
users <- width(users, j = 2, width = 1.5)
users <- width(users, j = 3:4, width = 0.65)
users <- width(users, j = 5, width = 1.75)
users <- width(users, j = 6, width = 0.95)
users <- width(users, j = 7, width = 1.75)
users <- width(users, j = 8, width = 1.2)
users <- width(users, j = 9, width = 0.95)

# Set theme
users <- theme_box(users)
users <- padding(users, padding.top = 0, part = "all")
users <- padding(users, padding.bottom = 0, part = "all")
users <- bg(users, bg = "#EFEFEF", part = "header")
fontsize(users, size = 9, part ="all")
```
<!---BLOCK_LANDSCAPE_STOP--->
