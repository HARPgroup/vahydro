---
date: "`r format(Sys.time(), '%m/%d/%Y')`"
author: ""
title: "`r params$doc_title`"
output: 
  officedown::rdocx_document:
    mapstyles:
      Normal: ['First Paragraph']
    page_margins:
      bottom: 0.5
      top: 0.5
      right: 1
      left: 0.5
      header: 0.0
      footer: 0.0
params: 
  doc_title: "VWP CIA Summary - [INSERT PROJECT NAME HERE]"
  rseg.hydroid: 68327 # Ex: Crooked Run = 476998, SF Powell below BSG = 477140, SF Powell at dam: 462757
  fac.hydroid: 73112 # Ex: Blue Ridge Shadows = 71977, BIG STONE GAP WTP = 72672: "runid_6014"
  runid.list: [ "runid_400","runid_600" ]
  fac.metric.list: [ "base_demand_mgy", "wd_mgy", "unmet_demand_mgy","base_demand_mgd","wd_mgd","ps_mgd","gw_demand_mgd","unmet30_mgd" ]
  rseg.metric.list: [ "Qout","remaining_days_p0","l30_Qout","l90_Qout","consumptive_use_frac","wd_cumulative_mgd","ps_cumulative_mgd","wd_mgd","ps_mgd" ]
  intake_stats_fid: FALSE
  intake_stats_runid: 11
  intake_stats_varname: "Qintake"
  preferred_runid: "runid_600"
  impoundment_fid: FALSE
  upstream_rseg_ids: FALSE
  downstream_rseg_ids: FALSE
  users_metric: "base_demand_mgy"
---

```{r setup, include=FALSE}
#"runid_201","runid_401","runid_6014","runid_6011","runid_6013","runid_6015","runid_6012"
#https://cran.r-project.org/web/packages/officedown/officedown.pdf
#https://ardata-fr.github.io/officeverse/officedown-for-word.html#insert-sections
knitr::opts_chunk$set(echo = TRUE, fig.cap = TRUE)
library(officedown)
library(officer)
library(flextable)
library(hydrotools)
library(rjson)
basepath='/var/www/R'
source('/var/www/R/config.R')
ds <- RomDataSource$new("http://deq1.bse.vt.edu/d.dh", rest_uname)
ds$get_token(rest_pw)

source("https://raw.githubusercontent.com/HARPgroup/hydro-tools/master/R/om_cia_table.R") #Used during development
source("https://raw.githubusercontent.com/HARPgroup/hydro-tools/master/R/om_demand_table.R") #Used during development
source("https://raw.githubusercontent.com/HARPgroup/hydro-tools/master/VAHydro-2.0/fn_get_prop.R") #Used during development
source("https://raw.githubusercontent.com/HARPgroup/hydro-tools/master/VAHydro-2.0/rest_functions.R") #Used during development
source("https://raw.githubusercontent.com/HARPgroup/hydro-tools/master/VAHydro-2.0/find_name.R") #Used during development
source("https://raw.githubusercontent.com/HARPgroup/hydro-tools/master/R/fac_utils.R") #Used until fac_utils is packaged
# Could also use:
#source("https://raw.githubusercontent.com/HARPgroup/hydro-tools/master/VAHydro-2.0/run_text.R") #Used during development

fp <- fp_par(
  text.align = "center", 
  padding.bottom = 20, padding.top = 120, 
  border.bottom = fp_border())

ft <- fp_text(shading.color='#EFEFEF', bold = TRUE)

```


```{r UserInputs, include=FALSE}
site.plots <- omsite #image files use http

#SPECIFY MODELS AND RUNIDS OF INTEREST

rseg.hydroid <- params$rseg.hydroid
fac.hydroid <- params$fac.hydroid
runid.list <- params$runid.list
fac.metric.list <- params$fac.metric.list
rseg.metric.list <- params$rseg.metric.list
intake_stats_fid <- params$intake_stats_fid
intake_stats_runid <- params$intake_stats_runid
intake_stats_varname <- params$intake_stats_varname
preferred_runid <- params$preferred_runid
impoundment_fid <- params$impoundment_fid
upstream_rseg_ids <- params$upstream_rseg_ids
downstream_rseg_ids <- params$downstream_rseg_ids
users_metric <- params$users_metric

if (is.logical(intake_stats_fid)) {
  intake_stats_fid = fac.hydroid
}
#runid.list <- c('runid_400','runid_600')
#runid.list <- c('runid_201','runid_401')
rlist <- gsub('runid_', '', runid.list)

# SALEM WTP:
# rseg.hydroid <- 68327
# fac.hydroid <- 73112
# runid.list <- c('runid_11','runid_12','runid_13')
# 
# fac.metric.list <- c('wd_mgd','ps_mgd','unmet30_mgd')
# rseg.metric.list <- c("Qout","Qbaseline","l30_Qout","l90_Qout","consumptive_use_frac","wd_cumulative_mgd","ps_cumulative_mgd")

#RSEG MODEL INFO
print(paste("searching", site,"for river segment id", rseg.hydroid))

#base_url = site, entity_id = rseg.hydroid

rseg.model <- RomProperty$new(
  ds,
  list(entity_type='dh_feature', featureid = rseg.hydroid, propcode="vahydro-1.0"),
  TRUE
)
rseg_feature <- RomFeature$new(
  ds,
  list(hydroid = rseg.hydroid),
  TRUE
)

#FAC MODEL INFO
fac.model <- RomProperty$new(
  ds,
  list(entity_type='dh_feature', featureid = fac.hydroid, propcode="vahydro-1.0"),
  TRUE
)
fac_feature <- RomFeature$new(
  ds,
  list(hydroid = fac.hydroid),
  TRUE
)
# need the intake hydroid for this, as there are no facility withdrawals
# only facility children, but we wouldn't want ALL facility children anyhow
annual_use_history <- fac_feature$tsvalues('wd_mgy')


fac.name <- fac_feature$name 


if (exists("json_obj_url")) {
  fac_obj_url <- paste(json_obj_url, fac.model$pid, sep="/")
  fac_model_info <- ds$auth_read(fac_obj_url, "text/json", "")
  fac_model_info <- fromJSON(fac_model_info)
  fac.elid <- fac_model_info[[1]]$om_element_connection$value

  rseg_obj_url <- paste(json_obj_url, rseg.model$pid, sep="/")
  rseg_model_info <- ds$auth_read(rseg_obj_url, "text/json", "")
  rseg_model_info <- fromJSON(rseg_model_info)
  rseg.elid <- rseg_model_info[[1]]$om_element_connection$value
  # get report customizations
  fac_report_info = find_name(fac_model_info, "reports")
  rseg_report_info = find_name(rseg_model_info, "reports")
  if (!is.logical(impoundment_fid)) {
    imp_model <- RomProperty$new(
      ds,
      list(entity_type='dh_feature', featureid = impoundment_fid, propcode="vahydro-1.0"),
      TRUE
    )
    imp_obj_url <- paste(json_obj_url, imp_model$pid, sep="/")
    imp_model_info <- om_auth_read(imp_obj_url, token,  "text/json", "")
    imp_model_info <- fromJSON(imp_model_info)
  }
} else {
  message("Error: json_obj_url is undefined.  Can not retrieve model and scenario information. (Hint: Use config.R to set json_obj_url) ")
  fac_model_info <- list()
  rseg_model_info <- list()
}


if (intake_stats_fid == fac.hydroid) {
  istats_elid = fac.elid
} else if (intake_stats_fid == rseg.hydroid) {
  istats_elid = rseg.elid
} else {
  istats_model <- RomProperty$new(
    ds,
    list(entity_type='dh_feature', featureid = intake_stats_fid, propcode="vahydro-1.0"),
    TRUE
  )
  istats_elid <- as.integer(as.character(istats_model$propvalues('om_element_connection')$propvalue))
}

fac_default_info = list(
  model_overview = list(
    "value" = "Facility intake model overview not provided."
  ),
  intake_name = list(
    "value"  = "un-named intake"
  ),
  project_intro = list(
    "value" = "General information about facility & intake (non-model specific)"
  )
)
rseg_default_info = list(
  model_overview = list(
    "value" = "River segment model overview not provided."
  )
)

fac_report_info <- merge.list(fac_report_info, fac_default_info)
rseg_report_info <- merge.list(rseg_report_info, rseg_default_info)   

# Pre load the output runs so we have them available for later use
# I think the om_get_prop here is no longer needed, rather, we 
short_names = list()
run_names = list()

for (i in 1:length(runid.list)){
  # get fac model run prop
  # get river model run prop 
  runid.i <- runid.list[i]
  run.i <- sub("runid_", "", runid.i)
  
  # TODO: prepopulate runid_XXX$report$facility_default_reports and riverseg_default_reports on the om_model_scenario variable to load as a default for these.  For example, runid11 is *always* the current WSP run, so there should be no need to give it a short name, or scenario name at the individual facility level.
  # stash short names since they are used frequently
  fac_run_info <- find_name(fac_model_info,runid.i)
  f_rep <- find_name(fac_run_info,'reports')
  # get the short name
  if (is.null(f_rep$scenario_short_name$value)) {
    short_names[[runid.i]] <- runid.i
  } else {
    short_names[[runid.i]] = as.character(f_rep$scenario_short_name$value)
  }
  # get the long name
  if (is.null(f_rep$scenario_name$value)) {
    run_names[[runid.i]] <- runid.i
  } else {
    run_names[[runid.i]] = as.character(f_rep$scenario_name$value)
  }
}


```

\newpage
# Project Introduction

```{r ProjectIntro, echo=FALSE, results = "asis"}
cat(paste(fac_report_info$project_intro$value,"\n\n"))
```

## Location Map

```{r GrabLocationMap, include=FALSE, echo=FALSE}
# fig_prop <- find_name(fac_model_info,"fig.location_map")
fig_prop <- om_get_prop(site,fac.model$pid, "dh_properties", "fig.location_map")
```

```{r LocationMap, echo=FALSE, results = "asis"}

if (!is.null(fig_prop) & !(is.boolean(fig_prop))) {
  map_path <- fig_prop$propcode
  cat(paste0("![](",map_path,")"),"\n")
} else {
  cat(paste0("*No location map available for this facility model*"))
}
``` 

\newpage
# Model Overview and Scenario Descriptions

```{r ModelOverview, echo=FALSE, results = "asis"}

cat("__River Model Description__\n")
cat(paste(rseg_report_info$model_overview$value,"\n\n"))
cat("__Facility & Intake Model Description__\n")
cat(paste(fac_report_info$model_overview$value,"\n\n"))
```

The following model scenarios were simulated in order to determine the most effective means of meeting the project need and all other in-stream beneficial uses:

```{r LoadRunInfo, echo=FALSE, results = "asis"}
for (i in 1:length(runid.list)){
  # get fac model run prop
  # get river model run prop 
  runid.i <- runid.list[i]
  run.i <- sub("runid_", "", runid.i)
  run_info <- find_name(fac_model_info,runid.i)
  
  if (is.null(run_info$reports)) {
    cat(paste("*", paste0("__",run_info$name,"__"),"-","Run report information not provided.","\n"))
  } else {
    ri <- run_info$reports
    cat(
      paste(
        "*", 
        paste0(
          "__",ri$scenario_name$value,"__", 
        " (", ri$scenario_short_name$value, ")"
        ),
        "-",run_info$reports$scenario_intro$value,"\n\n")
      )
  }
  
}

```



```{r LoadDemandTable, include=FALSE}
#-------------------------------------------------------------------------------
# fac_table <- om_model_table(model_info = fac_model_info,
#                             runid.list = runid.list,
#                             metric.list = fac.metric.list,
#                             site = site,
#                             site_base = omsite
# )

demand_table <- om_demand_table(model_info = fac_model_info,
                            runid.list =  runid.list)

demand_table <- cbind(rownames(demand_table),demand_table)
names(demand_table)[names(demand_table) == 'rownames(demand_table)'] <- 'Desc'
demand_table_raw <- demand_table

demand_table_sql <- paste('SELECT
                  CASE
                    WHEN "Desc" = "model" THEN "Facility Model Statistics:"
                    WHEN "Desc" = "avg_day_mgd" THEN "Average Daily Volume (MGD)"
                    WHEN "Desc" = "max_day_limit_mgd" THEN "Peak Day Volume (MGD)"
                    WHEN "Desc" = "max_ann_limit_mgy" THEN "Maximum Annual Volume (MG)"
                    ELSE Desc
                  END AS Description, *
                 FROM demand_table_raw
                 WHERE Desc NOT IN ("runid","model")
                 ',sep='')
demand_table <- sqldf(demand_table_sql)
demandsdf <- demand_table[,-2]
```

## Table of Modeled Demand Limits:
```{r DemandsTable, echo=FALSE}
demands <- qflextable(demandsdf)
# Set column widths
demands <- width(demands, j = 2:length(demandsdf[1,]), width = 1.7)
demands <- width(demands, j = 1, width = 1.9)
# Set theme
demands <- theme_box(demands)
# Set background color of select rows --------------------------------------------------------------
demands <- bg(demands, bg = "#EFEFEF", part = "header")
demands <-fontsize(demands, size = 10, part = "header")
fontsize(demands, size = 9)
```



\newpage  
__Historical Intake Flows and Drought Flow Indicators__  

The VAHydro model is used to estimate flows at the project intake, including the impact of all cumulative withdrawals and discharges upstream of the intake location and are presented in Table 1.  The Virginia Drought Assessment and Response Plan^[ [Virginia Drought Assessment and Response Plan](https://www.deq.virginia.gov/home/showpublisheddocument/5115/637490843054630000), developed by the Drought Response Technical Advisory Committee in response to Executive Order #39, March 28, 2003.] employs non-exceedance flow percentiles as indicators of drought conditions at particular stream-gaging stations used to monitor drought conditions.  Representative daily streamflows above the 25th percentile for return flow frequency represent normal conditions with respect to drought.  Representative daily streamflows between the 10th and 25th percentiles represent drought watch conditions. Representative daily streamflows between the 5th and 10th percentiles represent drought warning conditions.  Representative daily streamflows below the 5th percentile indicate drought emergency conditions.

```{r LoadSiteInfo, include=FALSE}
dat_current <- om_get_rundata(istats_elid, intake_stats_runid, omsite, FALSE)
# catch instances where older models did not have Qintake
# does this have an impoundment sub-comp and is imp_off = 0?
cols <- names(dat_current)
if(!(intake_stats_varname %in% cols)) {
  dat_current[,intake_stats_varname] <- dat_current$Qriver
}
intake_sum_current <- om_flow_table(dat_current, intake_stats_varname)
ex_col = "10%"
jan_ex <- intake_sum_current[1,ex_col]
if (jan_ex == 0) {
  ex_col = "25%"
}
jan_ex <- intake_sum_current[1,ex_col]
non_ex_text <- paste0("For example, in the table below the ",ex_col," column states that ",ex_col," of flows within the month of January would be less than ", round(jan_ex,0), " cfs.")
drun_info <- find_name(fac_model_info,paste0("runid_",intake_stats_runid))
demand_url <- drun_info$fig.monthly_demand$code
```

```{r SiteTable, echo=FALSE, results = "asis"}
#Round Table Values (Following McGurk request: "The tabulated values should be rounded to the nearest whole number.  The flow estimates at the stream gages are not precise or accurate enough for digits to the right of the decimal, and are not reported that way.  Therefore, modeled values should not be considered more accurate.")
# I allowed this to be 1 decimal place because when you have small watersheds, you can end up with a table of flows that are half populated with zeros. This results in the table being LESS accurate IMO than rounding to 1 place.  FWIW, the decimal places are not accuracy, they're precision so I'd argue that the model can be more precise cause it's a numerical calculation and therefore more precise :)
mism <- median(intake_sum_current$Mean)
if (mism < 20.0) {
  dps <- 1
} else {
  dps = 0
}
round_intake_sum_current <- intake_sum_current[2:length(intake_sum_current)]
round_intake_sum_current <- round(round_intake_sum_current,dps)
intake_sum_current <- cbind(intake_sum_current[1],round_intake_sum_current)

# Format table
ft <- qflextable(intake_sum_current)
ft <- theme_box(ft)
ft <- bg(ft, bg = "#EFEFEF", part = "header")
ft
cat(
  paste(
    "__Table 1:__ Modeled monthly current flow statistics for", 
    fac_report_info$intake_name$value, 
    "in cubic feet per second (cfs). Columns show the minimum (Min) and average (Mean) modeled flow, and a range of non-exceedance flow percentiles, that is, the percent of flows that do *not* exceed the given value. For example, the",
    paste0("\"",ex_col, "\""), "states that only", ex_col, 
    "of flows in the given month are expected to be less than the indicated value, and therefore, 90% of the flows in that month are expected to be greater than the given value.", 
    non_ex_text
  )
)

if (!is.null(demand_url)) {
    cat("\n\n## Current Facility Base Demand Before Conservation: ", drun_info$reports$scenario_name$value,"\n\n")
    cat(paste0("![](",demand_url,")"),"\n")
    cat("\n\n\\pagebreak\n")
} else {
  #cat("NULL demand_url\n")
  cat(" ")
}
```
  
\newpage
# Results
## Summary

```{r LoadRunResults, echo=FALSE, results = "asis"}

cat(paste("Presented below are ",length(runid.list)," scenarios to examine the alternatives for this permit re-issuance.  A summary of how permit rules affect available water for this permit, and how this operation may impact instream beneficial uses, and other downstream water withdrawals is presented.\n\n"))

for (i in 1:length(runid.list)){
  # get fac model run prop
  # get river model run prop 
  runid.i <- runid.list[i]
  run.i <- sub("runid_", "", runid.i)
  run_info <- find_name(fac_model_info,runid.i)
  if (is.null(run_info$reports)) {
    cat(paste("*", paste0("__",run_names[runid.i],"__"),"-","Run analysis not provided.","\n"))
  } else {
    ri <- run_info$reports
    cat(
      paste(
        "*", 
        paste0(
          "__",ri$scenario_name$value,"__"
        ),
        "-",run_info$reports$scenario_analysis$value,"\n")
      )
  }
  
}
```


```{r CUTable, echo=FALSE, include=FALSE}

runid.i <- preferred_runid
run.i <- sub("runid_", "", runid.i)
run_info <- find_name(fac_model_info,runid.i)
pr_data <- om_get_rundata(rseg.elid, run.i, omsite, FALSE)
pr_data$Qbaseline <- pr_data$Qout + (pr_data$wd_cumulative_mgd - pr_data$ps_cumulative_mgd) * 1.547
pr_data$cu_daily <- (
  -100.0 * (pr_data$wd_cumulative_mgd - pr_data$ps_cumulative_mgd) * 1.547 
  / (
    pr_data$Qout + (pr_data$wd_cumulative_mgd - pr_data$ps_cumulative_mgd) * 1.547
  )
)
cu_table = om_flow_table(pr_data, 'cu_daily')
q_table = om_flow_table(pr_data, 'Qout')
qcu_table = q_table
qcu_colors = matrix(nrow = nrow(q_table), ncol = ncol(q_table))
rn = 0
for (r in rownames(q_table)) {
  rn = rn + 1
  cn = 0
  for (c in colnames(q_table[r,])) {
    cn = cn + 1
    qcu_colors[rn,cn] = "white"
    if (cu_table[r,c] <= -10.0) {
      qcu_colors[rn,cn] = "yellow"
    } 
    if (cu_table[r,c] <= -20.0) {
      qcu_colors[rn,cn] = "orange"
    } 
    qcu_table[r,c] <- paste0( q_table[r,c], " (", cu_table[r,c],"%)")
  }
}

fqcu_table <- flextable(qcu_table)
fqcu_table <- bg(fqcu_table, bg = "#EFEFEF", part = "header")

for (i in 1:nrow(qcu_colors)) {
  for (j in 1:ncol(qcu_colors)) {
    fqcu_table <- bg(fqcu_table, i, j, bg = qcu_colors[i,j])
  }
}

fqcu_caption <- paste(
  "Modeled monthly consumptive use statistics in the ", 
  rseg_feature$name, "in cubic feet per second (cfs). Columns show the modeled non-exceedance flow percentiles and the associated consumptive user percentage due to cumulative demands for the", 
  run_info$reports$scenario_name$value, 
  "scenario. Simulated demands include all up-stream demands as well as simulated demands at the", 
  fac_feature$name, fac_report_info$intake_name$value, 
  "intake ) and cumulative return flows.  "
)
fqcu_table <- set_caption(
  fqcu_table,
  caption = fqcu_caption,
  autonum = NULL,
  word_stylename = "Table Caption",
  fp_p = NULL,
  align_with_table = TRUE,
  html_classes = NULL,
  html_escape = TRUE
)

```

## Conclusion

```{r LoadConclusions, echo=FALSE, results = "asis"}

runid.i <- preferred_runid
run.i <- sub("runid_", "", runid.i)
run_info <- find_name(fac_model_info,runid.i)
if (is.null(run_info$reports)) {
  cat(paste("*", paste0("__",run_names[runid.i],"__"),"-","Preferred scenario, ", runid.i, ", conclusions not provided.","\n", "Conclusions should be stored in [model] -> ", run.i, " -> reports -> conclusions"))
} else {
  cat(
    paste(
      "*", 
      paste0(
        "__",run_info$reports$scenario_name$value,"__"
      ),
      "-",run_info$reports$conclusions$value,"\n", "\n\n\n")
    )
}

cat("\n\n\n")

fqcu_table
  
cat("\n")
demand_chart_caption <- paste("Facility Base Demand Before Conservation", run_info$reports$scenario_name$value)
demand_url <- run_info$fig.monthly_demand$code

if (is.null(demand_url)) {
  demand_url = " "
}
#cat(paste0("![](",demand_url,")"),"\n")

```


```{r LoadStatsTable, include=FALSE}
#-------------------------------------------------------------------------------
fac_table <- om_model_table(model_info = fac_model_info,
                            runid.list = runid.list,
                            metric.list = fac.metric.list,
                            site = site,
                            site_base = omsite
)
fac_table <- cbind(rownames(fac_table),fac_table)
names(fac_table)[names(fac_table) == 'rownames(fac_table)'] <- 'Desc'
fac_table_raw <- fac_table

fac_table_sql <- paste('SELECT
                  CASE
                    WHEN "Desc" = "model" THEN "Facility Model Statistics:"
                    WHEN "Desc" = "unmet30_mgd" THEN "Maximum 30 day potential unmet demand (MGD)"
                    WHEN "Desc" = "base_demand_mgy" THEN "Base Demand (MGY)"
                    WHEN "Desc" = "wd_mgy" THEN "Withdrawal (MGY)"
                    WHEN "Desc" = "unmet_demand_mgy" THEN "Unmet Demand (MGY)"
                    WHEN "Desc" = "base_demand_mgd" THEN "Requested Demand (MGD)"
                    WHEN "Desc" = "wd_mgd" THEN "Withdrawal Met (MGD)"
                    WHEN "Desc" = "ps_mgd" THEN "Point Source (MGD)"
                    WHEN "Desc" = "gw_demand_mgd" THEN "Groundwater Demand (MGD)"
                    ELSE Desc
                  END AS Description, *
                 FROM fac_table_raw
                 WHERE Desc NOT IN ("riverseg","run_date","starttime","endtime","runid")
                 ',sep='')
fac_table <- sqldf(fac_table_sql)
fac_table <- fac_table[,-2]
#-------------------------------------------------------------------------------
rseg_table <- om_model_table(model_info = rseg_model_info,
                             runid.list = runid.list,
                             metric.list = rseg.metric.list,
                             include.elfgen = TRUE,
                             site = site,
                             site_base = omsite
)
rseg_table <- cbind(rownames(rseg_table),rseg_table)
names(rseg_table)[names(rseg_table) == 'rownames(rseg_table)'] <- 'Desc'
rseg_table_raw <- rseg_table

rseg_table_sql <- paste('SELECT
                  CASE
                    WHEN "Desc" = "model" THEN "River Segment Model Statistics:"
                    WHEN "Desc" = "Qout" THEN "Flow Out (cfs) - (i.e mean flow)"
                    WHEN "Desc" = "Qbaseline" THEN "Flow Baseline (cfs)"
                    WHEN "Desc" = "remaining_days_p0" THEN "Minimum Days of Storage Remaining"
                    WHEN "Desc" = "l30_Qout" THEN "30 Day Low Flow (cfs) (i.e drought flow)"
                    WHEN "Desc" = "l90_Qout" THEN "90 Day Low Flow (cfs) (i.e drought flow)"
                    WHEN "Desc" = "consumptive_use_frac" THEN "Consumptive Use Fraction"
                    WHEN "Desc" = "wd_cumulative_mgd" THEN "Cumulative Withdrawal (MGD)"
                    WHEN "Desc" = "ps_cumulative_mgd" THEN "Cumulative Point Source (MGD)"
                    WHEN "Desc" = "wd_mgd" THEN "Withdrawal (MGD)"
                    WHEN "Desc" = "ps_mgd" THEN "Point Source (MGD)"
                    ELSE Desc
                  END AS Description, *
                 FROM rseg_table_raw
                 WHERE Desc NOT IN ("riverseg","run_date","starttime","endtime","richness_change_abs","richness_change_pct","runid")
                 ',sep='')
rseg_table <- sqldf(rseg_table_sql)
rseg_table <- rseg_table[,-2]
colnames(rseg_table) <- colnames(fac_table) #Col names need to match before rbind
#-------------------------------------------------------------------------------
statsdf <- rbind(rseg_table,fac_table)
```

\newpage
## Detailed Cumulative Impact Analysis
The following "Summary of Results" table summarizes the cumulative impacts to flows, aquatic life, and off-stream demand for the project. The section entitled “River Segment Model Statistics” contains mean flows (Flow Out), and drought flows (30 and 90 Day Low Flow), as well as an estimated Consumptive Use Fraction (See description below) as a result of all withdrawals (Cumulative Withdrawal) and discharges (Cumulative Point Source) in the watershed. Minimum Days of Storage Remaining describes the number of days of remaining storage available during the driest period of the model simulation (applicable to impoundment models only). Total Number of Days with Storage < 50% describes the number of days in the simulation in which reservoir levels fall below 50% of full storage. The section entitled “Facility Model Statistics” shows the withdrawals, return flows (Point Source), and the model estimate for potential unmet demand due to demands exceeding the allowable withdrawal at the intake based on the cumulative conditions in the watershed and the flow-by rules in effect. There will be one or more columns in this table representing each scenario considered for this analysis.

<!---BLOCK_LANDSCAPE_START--->
### Summary of Results:
```{r StatsTable, echo=FALSE}
ft <- qflextable(statsdf)

# Set column widths
ft <- width(ft, j = 2:length(statsdf[1,]), width = 1.9)
ft <- width(ft, j = 1, width = 2.5)

# Add header row -----------------------------------------------------------------------------------
# ft <- add_header_row(x = ft, values = c("", "Scenario Alternatives"),colwidths = c(3, 4))

# Set theme
ft <- theme_box(ft)

# Set background color of select rows --------------------------------------------------------------
ft <- bg(ft, bg = "#EFEFEF", part = "header")
ft <- bg(ft, i = ~ Description == "River Segment Model Statistics:", bg = "#EFEFEF", part = "body")
ft <- bg(ft, i = ~ Description == "Facility Model Statistics:", bg = "#EFEFEF", part = "body")
fontsize(ft, size = 9)
```
<!---BLOCK_LANDSCAPE_STOP--->


### Analysis of Reservoir Storage:
The following reservoir storage plots depict changes in reservoir storage under each scenario (indicated in black), as well as simulated inflow to the reservoir (blue), simulated outflow from the reservoir (green), and system demand for the given scenario (red). For water supply reservoirs, a minimum of 60 days of remaining storage over the course of the simulation is recommended. System demand varies seasonally.

```{r ResPLOTS, echo=FALSE, message=FALSE, results = "asis"}

# check river model for plots
for (i in 1:length(runid.list)){
  # get fac model run prop
  # get river model run prop 
  runid.i <- runid.list[i]
  run_info <- find_name(rseg_model_info,runid.i)
  fig_prop <- find_name(run_info, "fig.imp_storage.all")
  if (!(is.null(fig_prop))) {
    fig_path <- fig_prop$code
    # we have an image, show it 
    cat("\n\n#### Reservoir Storage: ", short_names[[runid.i]],"\n\n")
    cat(paste0("![](",fig_path,")"),"\n")
    cat("\n\n\\pagebreak\n")
  } else {
    # tbd: try impoundment linked to river segment.
    print(paste("No active impoundment found for run id",runid.i))
  }
  if (!is.logical(impoundment_fid)) {
    run_info <- find_name(imp_model_info,runid.i)
    fig_prop <- find_name(run_info, "fig.imp_storage.all")
    if (!(is.null(fig_prop))) {
      fig_path <- fig_prop$code
      # we have an image, show it 
      cat("\n\n#### Reservoir Storage: ", short_names[[runid.i]],"\n\n")
      cat(paste0("![](",fig_path,")"),"\n")
      cat("\n\n\\pagebreak\n")
    } else {
      # tbd: try impoundment linked to river segment.
      print(paste("No active impoundment found for run id",runid.i,"on impoundment feature", impoundment_fid)) 
    }
  }
}

``` 

\newpage

### Analysis of Potential Unmet Demand at the River Intake:
The following grids are data plotting tools that help visualize data as magnitudes of color intensity. These depict the number of days with unmet demands for each month of the simulation (due to demands exceeding allowable withdrawal at the intake based on the cumulative conditions in the watershed and the flow-by rules in effect). The cells show the amount of unmet demand for each month [Number of Unmet Days & Amount (MGD)]. Hydrographs are shown for the period of the simulation with greatest unmet demand.

```{r UnmetDemandPLOTS, echo=FALSE, message=FALSE, results = "asis"}

# check facility model for plots
for (i in 1:length(runid.list)){
  # get fac model run prop
  # get river model run prop 
  runid.i <- runid.list[i]
  run.i <- sub("runid_", "", runid.i)
  fac_run <- find_name(fac_model_info, runid.i)
  fig_prop <- invisible(find_name(fac_run, "fig.unmet_heatmap_amt"))
  if (!(is.null(fig_prop))) {
    fig_path <- fig_prop$code
    # we have an image, show it 
    cat("\n\n#### Unmet Demand: ",short_names[[runid.i]],"\n\n")
    cat(paste0("![](",fig_path,")"),"\n")
  }
  fig_prop <- invisible(find_name(fac_run, "fig.30daymax_unmet"))
  if (!(is.null(fig_prop))) {
    fig_path <- fig_prop$code
    # we have an image, show it 
    cat("\n\n#### Hydrograph: ",short_names[[runid.i]],"\n\n")
    cat(paste0("![](",fig_path,")"),"\n")
    #cat("\n\n\\pagebreak\n")
  }
  fig_prop <- invisible(find_name(fac_run, "fig.imp_storage.all"))
  if (!(is.null(fig_prop))) {
    fig_path <- fig_prop$code
    # we have an image, show it 
    cat("\n\n#### Reservoir Storage: ",short_names[[runid.i]],"\n\n")
    cat(paste0("![](",fig_path,")"),"\n")
  } else {
    # JK - do we want to simply supress in order to have better formatting? or maybe keep a count
    # of missing images so we can alert the user to which entities lack impoundments?
    print(paste("No local facility impoundment for ",short_names[[runid.i]]))
  }
  cat("\n\n\\pagebreak\n")
  
}

``` 

\newpage

### Additional Model Flow Plots:

```{r FDCplots, echo=FALSE, message=FALSE, results = "asis"}

# check rseg model for plots
for (i in 1:length(runid.list)){
  # get river model run prop 
  runid.i <- runid.list[i]
  rseg_run <- find_name(rseg_model_info, runid.i)
  fig_prop <- invisible(find_name(rseg_run, "fig.fdc"))
  if (!(is.null(fig_prop))) {
    fig_path <- fig_prop$code
    # we have an image, show it 
    cat("\n\n#### ",short_names[[runid.i]],":","\n\n")
    cat(paste0("![](",fig_path,")"),"\n")
  }
  
  fig_prop <- invisible(find_name(rseg_run, "fig.hydrograph_dry"))
  if (!(is.null(fig_prop))) {
    fig_path <- fig_prop$code
    # we have an image, show it 
    cat("\n\n#### ",short_names[[runid.i]],":","\n\n")
    cat(paste0("![](",fig_path,")"),"\n")
    #cat("\n\n\\pagebreak\n")
  } 
  
  cat("\n\n\\pagebreak\n")
  
}

```

\newpage

# VAHydro Model:

## Appendix B - VAHydro
The comprehensive VAHydro hydrologic model is used by the DEQ Office of Water Supply to evaluate instream and off-stream beneficial uses for non-tidal surface water withdrawals throughout Virginia. This model also simulates streamflow with inputs such as precipitation, climate, land use, and topography, as well as local data collected through DEQ water supply planning and reporting programs, which includes all known withdrawals and discharges, as well as operational rules of Virginia Water Protection (VWP) permits and major hydrologic features such as reservoirs.

The VAHydro model is built on the rainfall-evaporation-runoff (RER) time-series from the Chesapeake Bay Model Phase 6^[ [Chesapeake Bay Program Phase 6 Model](https://www.chesapeakebay.net/documents/Phase_6_Modeling_Tools_1-page_factsheet_12-18-17.pdf).]. The VAHydro model simulates conditions from 1984-2014 in the Chesapeake Bay watershed drainage, and 1984-2005 in the rivers flowing outside of the Chesapeake Bay watershed. The VAHydro model features high-resolution hydrologic subsections called “river segments” (over 600 river segments in total), roughly the size of HUC 10 hydrologic units, with additional high-resolution segments added for VWP modeling projects as needed.


## Cumulative Impact Analysis (CIA)
DEQ assesses water supply sustainability through Cumulative Impact Analysis (CIA). CIA is a modeling and analysis approach that takes into account the varied hydrologic processes occurring throughout a river network (including meteorological and human water use). By simulating a daily water balance for every individual river segment within a watershed, DEQ is able to evaluate the potential “cumulative impact” of all streamflow changes occurring upstream and downstream of any location within the river system, as well as the downstream impact of a specific proposed or permitted surface water withdrawal.

The goal of the following analysis is to estimate the potential impacts of the proposed water withdrawal upon existing beneficial uses, including both in-stream and off-stream uses. In addition, cumulative impacts from all existing withdrawals are included in the evaluation.


### Glossary of Cumulative Impact Modeling Terms
- 30 Day Low Flow (l30):  Describes the lowest consecutive 30 day average daily streamflow over the simulation period. This metric is a representation of a short-term, or acute drought.
- 90 Day Low Flow (l90): Represents the lowest consecutive 90 day average daily streamflow over the simulation period. This would represent a prolonged drought.
- Base Demand / Requested Demand: The demand simulated for a facility/intake prior to any reductions due to conservation, depleted storage, or adherence to Minimum Instream Flow operational rules (MIF).  In this document, *Base Demand* is expressed as *MGY*, and Requested Demand is given in *MGD*.
- CFS: Cubic Feet Per Second, a common unit of measuring stream flow.
- Consumptive Use Fraction (CU): This is calculated as a fraction of modeled Flow, so it is CU = 1.0 - (Flow / Flow_Baseline), where Flow_Baseline = (Flow + WD - PS), and WD and PS are the total cumulative withdrawals and point source discharges above the point in the stream.  In other words, for calculating baseline flow, we take modeled outflow from the river, add the withdrawals back in, and subtract the point source in order to estimate a baseline flow balance.  This almost always ends up being a higher number than the modeled Flow out, so it tells us the fraction of baseline flow that is consumed.  Occasionally there are water transfers and point sources from groundwater, or point sources that cross watershed boundaries that can make the CU fraction in some watersheds negative, i.e. Flow > Flow_Baseline.
- Cumulative Withdrawal: The amount of water withdrawn by all intakes in a given river segment sub-watershed, and all upstream sub-watersheds. See also: *Cumulative Withdrawal*.
- Days of Storage Remaining: For reservoir models, the quotient of the volume of water in a reservoir divided by the daily rate of withdrawal, calculated at each time step of the entire simulation period.
- Maximum 30 day potential unmet demand (MGD): The largest difference between *Requested Demand* and *Withdrawal Met* that results during a continuous 30-day simulation period.
- MGD: Millions of Gallons per Day, a common unit of measuring withdrawal and discharge.
- MGY: Millions of Gallons per Year, a common unit for expressing annual facility demand.
- Minimum Days of Storage Remaining: The minimum simulated *Days of Storage Remaining* in a reservoir.
- Point Source: Water returned to the stream as treated wastewater.
- Withdrawal: The amount of water withdrawn by a single facility, or the total amount of water withdrawn within a single simulated river segment sub-watershed. See also: *Cumulative Withdrawal*.
- Withdrawal Met: The amoiunt of requested demand that was met, on average, throughout the entire simulation period.
- Unmet Demand: The difference between *Base Demand* and *Withdrawal Met*, on average, throughout the entire simulation period.

\newpage

# Appendix A - Ecological Impacts Assessment:

## Elfgen:
In response to a need for better environmental flow metrics, DEQ has developed a new framework for characterizing relations between streamflow and aquatic organism species richness. Part of an evolving approach to managing environmental flows for maintaining aquatic life; this methodology builds on existing minimum instream ow approaches, allowable withdrawals as a percentage of flow, and extensive flow-habitat studies. For the first time this new framework may allow quantification of potential species loss resulting from flow change, and may offer an improved understanding of aquatic life risk variability due to geographic location, stream size and local scale.

This new flow-ecology framework referred to as “elfgen” (*pronounced elf-jen*) derives its name from Ecological Limit Function (ELF) generation (*ELF-gen*). In order to calculate river segment-level richness change, elfgen is first used to produce ELFs, or relations between stream flow and species richness at the HUC 8 scale (See plot below). This is achieved using long term datasets for both ecological and hydrologic data. Ecological data (Fish species richness) is sourced from the VAHydro-EDAS dataset. Hydrologic data (Average Annual Flow) is sourced from the National Hydrography Dataset Plus. The Richness Change values presented in the table below are derived from this flow-ecology relation.


```{r GrabELFPlot, include=FALSE, echo=FALSE}
# Need to have a switch based on draiange area with text such as:
# Ecological Limit Functions are not available for this location because the drainage area exceeds 800 square miles, which is beyond the applicable range of current mean flow based ecological limit functions.


run_container <- om_get_prop(site, rseg.model$pid, entity_type = 'dh_properties',runid.list[1])
fig_path = FALSE
elfgen_EDAS_huc8 <- om_get_prop(site, run_container$pid, entity_type = 'dh_properties','elfgen_EDAS_huc8')
if (!is.logical(elfgen_EDAS_huc8)) {
  fig.elfgen <- om_get_prop(site, elfgen_EDAS_huc8$pid, entity_type = 'dh_properties','fig.elfgen')
  if (!is.logical(fig.elfgen)) {
    fig_path <- fig.elfgen$propcode
  }
}
``` 

```{r elfPlot, echo=FALSE, results = "asis"}
if (!is.logical(fig_path)) {
  cat(paste0("![](",fig_path,")"),"\n")

} else {
  cat(paste0("*No elfgen plot available for this model*"))
}
```

\newpage

## Richness Change Metric Table:
Estimates for richness change are presented both as an absolute number of species (Richness Change (abs)) and as a percentage of the total number of species present (Richness Change (%)). Richness change calculations are derived from the estimated percent total consumptive use^[Kleiner et al: [https://onlinelibrary.wiley.com/doi/full/10.1111/1752-1688.12876](https://onlinelibrary.wiley.com/doi/full/10.1111/1752-1688.12876) & Rapp et al: [https://onlinelibrary.wiley.com/doi/full/10.1111/1752-1688.12877](https://onlinelibrary.wiley.com/doi/full/10.1111/1752-1688.12877)]. Note: elfgen methodology only applicable for watersheds < 800 cfs mean annual flow.

```{r LoadRichnessTable, include=FALSE}
elfgen_cu <- rseg_table_raw

cu_sql <- paste('SELECT * FROM elfgen_cu WHERE Desc == "consumptive_use_frac" ',sep='')
cu_sql <- sqldf(cu_sql)
cu_pct <- as.numeric(cu_sql[1,-1])*100
cu_pct <- c("Consumptive Use (%)",cu_pct)
#cu_pct <- c("Consumptive Use (%)",format(round(cu_pct,2), nsmall = 2)) #can adjust sigfigs

elfgen_df <- rseg_table_raw
elfgen_sql <- paste('SELECT
                      CASE
                        WHEN "Desc" = "rseg_model" THEN "River Segment Model Statistics:"
                        WHEN "Desc" = "consumptive_use_frac" THEN "Consumptive Use Fraction"
                        WHEN "Desc" = "wd_cumulative_mgd" THEN "Cumulative Withdrawal (MGD)"
                        WHEN "Desc" = "richness_change_abs" THEN "Richness Change (abs)"
                        WHEN "Desc" = "richness_change_pct" THEN "Richness Change (%)"
                        ELSE Desc
                      END AS Description, *
                    FROM elfgen_df
                    WHERE Desc IN ("rseg_model","consumptive_use_frac","wd_cumulative_mgd","richness_change_abs","richness_change_pct")
                    ',sep='')
elfgen_df <- sqldf(elfgen_sql)
elfgen_df <- elfgen_df[,-2]
elfgen_df <- elfgen_df[-1,] #remove row with CU as a decimal
elfgen_df <- rbind(cu_pct,elfgen_df) #add row with CU as a percent
colnames(elfgen_df) <- colnames(fac_table) #colnames to use scenario names
```

```{r RichnessTable, echo=FALSE}
ft <- qflextable(elfgen_df)
# Set column widths
  ft <- width(ft, j = 2:length(elfgen_df[1,]), width = 1.5)
  ft <- width(ft, j = 1, width = 2.0)
# Set theme
  ft <- theme_box(ft)
# Set background color of select rows --------------------------------------------------------------
  ft <- bg(ft, bg = "#EFEFEF", part = "header")
  fontsize(ft, size = 9)
```


## Habitat (If Applicable):

\newpage


```{r LoadRsegWithdrawalsTable, include=FALSE}
    #runid <- last(runid.list) #Old option for using the last runid in the runid.list
    runid <- preferred_runid #New method for using the preferred_runid
    #-------------------------------------------------------------------
    run_info.fac <- find_name(fac_model_info,runid)
    if (is.null(run_info.fac$reports)) {
      scenario_short_name <- runid
    } else {
      scenario_short_name <- as.character(run_info.fac$reports$scenario_short_name$value)
    }
    #-----------------------------------------------------------------
    #col_header <- paste(runid,": ",users_metric,sep="")
    col_header <- paste(scenario_short_name,": ",users_metric,sep="")
#if (length(upstream_rseg_ids) > 0 & length(downstream_rseg_ids) > 0) {
if (isFALSE(upstream_rseg_ids) == FALSE & length(upstream_rseg_ids) > 0 & isFALSE(downstream_rseg_ids) == FALSE & length(downstream_rseg_ids) > 0) { 
  # get users in all relevant segments
  users_uri <- paste(
    site,"/contains-mps-model-summary-export/",
    rseg.hydroid,
    ",", gsub(" ","",toString(upstream_rseg_ids)),
    ",", gsub(" ","",toString(downstream_rseg_ids)),
    sep=""
  )
  users_df <- as.data.frame(
    ds$auth_read(users_uri, "text/csv", "")
  )
  metric_df <- read.csv(
    paste(
      site,"/model-summary-users-export/",rseg.hydroid,",",
      gsub(" ","",toString(upstream_rseg_ids)),",",
      gsub(" ","",toString(downstream_rseg_ids)),
      "/",runid,"/",users_metric,
      sep=""
    )
  )
} else if (isFALSE(upstream_rseg_ids) == FALSE & length(upstream_rseg_ids) > 0) {
    users_up_df <- read.csv(paste(site,"/contains-mps-model-summary-export/",rseg.hydroid,",",gsub(" ","",toString(upstream_rseg_ids)),sep=""))
    users_up_df <- cbind(users_up_df,Location="Upstream")
    users_df <- users_up_df
    users_df[which(users_df$rseg_hydroid == rseg.hydroid),]$Location <- "-" #INDICATE WHICH USERS ARE IN THE SAME SEGMENT AS VWP PROJECT FACILITY
    metric_df <- read.csv(paste(site,"/model-summary-users-export/",rseg.hydroid,",",
                                gsub(" ","",toString(upstream_rseg_ids)),"/",runid,"/",users_metric,sep=""))
} else if (isFALSE(downstream_rseg_ids) == FALSE & length(downstream_rseg_ids) > 0) {
    users_dn_df <- read.csv(paste(site,"/contains-mps-model-summary-export/",rseg.hydroid,",",gsub(" ","",toString(downstream_rseg_ids)),sep=""))
    users_dn_df <- cbind(users_dn_df,Location="Downstream")
    users_df <- users_dn_df
    users_df[which(users_df$rseg_hydroid == rseg.hydroid),]$Location <- "-" #INDICATE WHICH USERS ARE IN THE SAME SEGMENT AS VWP PROJECT FACILITY
    metric_df <- read.csv(paste(site,"/model-summary-users-export/",rseg.hydroid,",",
                                gsub(" ","",toString(downstream_rseg_ids)),"/",runid,"/",users_metric,sep=""))    
} else {
    users_df <- read.csv(paste(site,"contains-mps-model-summary-export",rseg.hydroid,sep="/"))
    users_df <- cbind(users_df,Location="-")
    metric_df <- read.csv(paste(site,"/model-summary-users-export/",
                         rseg.hydroid,"/",runid,"/",users_metric,sep=""))
}
#########################################################################################  
#MP 5-yr Avg Current Annual Use (MGY)
#Facility 5-yr Avg Current Annual Use (MGY)
#Facility Projected 2040 Use (MGY)
users_sql <- paste(
  'SELECT facility_hydroid,
    CASE 
      WHEN usersdf.rseg_hydroid IN (', 
        gsub(" ","",toString(upstream_rseg_ids)), ') THEN \'Upstream\'',
     'WHEN usersdf.rseg_hydroid IN (', 
        gsub(" ","",toString(downstream_rseg_ids)), ') THEN \'Downstream\'',
     'ELSE \'-\' ',
    'END AS "Location", 
    usersdf.polygon_name AS "Sub-Watershed",
    usersdf.mp_bundle AS "MP Type",
    usersdf.mp_name AS "MP Name",
    usersdf.mp_wd_current_mgy AS "MP 5-yr Avg Use (MGY)",         
    usersdf.facility_name AS "Facility Name",
    usersdf.facility_wd_current_mgy AS "Facility 5-yr Avg Use (MGY)",
    usersdf.facility_wsp2020_2040_mgy AS "Facility 2040 Use (MGY)",
    metricdf.metric_value AS "', col_header,
'"FROM users_df AS usersdf
  LEFT OUTER JOIN metric_df as metricdf
  ON usersdf.mp_hydroid = metricdf.mp_hydroid
  WHERE usersdf.mp_bundle = "intake"
  ORDER BY metricdf.metric_value DESC
')
#ORDER BY mp_wd_current_mgy DESC
#WHERE mp_wd_current_mgy > 0
#WHERE usersdf.mp_bundle = "intake"
#ORDER BY metricdf.metric_value DESC
usersdf <- sqldf(users_sql)
usersdf <- cbind(" "=seq.int(nrow(usersdf)),usersdf) #ADD COLUMN OF ROW NUMBER 

#VWP model facility row(s)
# this fixes when the facility name does not match the 
# model facility name through renaming, or capitalization
fac.rows <- which(usersdf$`facility_hydroid` == fac.hydroid)
# now, remove the facility_hydroid column
fhix <- which(colnames(usersdf) != 'facility_hydroid')
usersdf <- usersdf[fhix]

```

<!---BLOCK_LANDSCAPE_START--->
# Appendix C - Nearby Users Table:
```{r RsegWithdrawalsTable, echo=FALSE}
#cat(paste("MP 5-yr Avg Use (MGY) refers to the 5-year average current annual Use (MGY) based on reported withdrawals"))
users <- qflextable(usersdf)

# Set column widths
users <- width(users, j = 1, width = 0.4)
users <- width(users, j = 2, width = 0.9)
users <- width(users, j = 3, width = 1.5)
users <- width(users, j = 4, width = 0.65)
users <- width(users, j = 5, width = 1.75)
users <- width(users, j = 6, width = 0.95)
users <- width(users, j = 7, width = 1.75)
users <- width(users, j = 8, width = 1.2)
users <- width(users, j = 9, width = 0.95)
users <- width(users, j = 10, width = 1.0)

# Set theme
users <- theme_box(users)
users <- padding(users, padding.top = 0, part = "all")
users <- padding(users, padding.bottom = 0, part = "all")
users <- bg(users, bg = "#EFEFEF", part = "header")
users <- bg(users, i = fac.rows, bg = "slategray1")
fontsize(users, size = 9, part ="all")
```
<!---BLOCK_LANDSCAPE_STOP--->
